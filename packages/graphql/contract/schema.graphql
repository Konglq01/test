type Query {
  tokenInfo(dto: GetTokenInfoDto): [TokenInfoDto]
  nftProtocolInfo(dto: GetNFTProtocolInfoDto): [NFTProtocolInfoDto]
  caHolderTransaction(dto: GetCAHolderTransactionDto): [CAHolderTransactionDto]
  caHolderManagerInfo(dto: GetCAHolderManagerInfoDto): [CAHolderManagerDto]
  loginGuardianAccountInfo(
    dto: GetLoginGuardianAccountInfoDto
  ): [LoginGuardianAccountDto]
  userNFTProtocolInfo(dto: GetUserNFTProtocolInfoDto): [UserNFTProtocolInfoDto]
  userNFTInfo(dto: GetUserNFTInfoDto): [UserNFTInfoDto]
  caHolderTokenBalanceInfo(
    dto: GetCAHolderTokenBalanceDto
  ): [CAHolderTokenBalanceDto]
  caHolderTransactionAddressInfo(
    dto: GetCAHolderTransactionAddressDto
  ): [CAHolderTransactionAddressDto]
  loginGuardianAccountChangeRecordInfo(
    dto: GetLoginGuardianAccountChangeRecordDto
  ): [LoginGuardianAccountChangeRecordDto]
  caHolderManagerChangeRecordInfo(
    dto: GetCAHolderManagerChangeRecordDto
  ): [CAHolderManagerChangeRecordDto]
  caHolderSearchTokenNFT(
    dto: GetCAHolderSearchTokenNFTDto
  ): [CAHolderSearchTokenNFTDto]
  syncState(dto: GetSyncStateDto): SyncStateDto
}

type TokenInfoDto {
  id: String
  chainId: String
  blockHash: String
  blockHeight: Long!
  previousBlockHash: String
  symbol: String
  tokenContractAddress: String
  decimals: Int!
  totalSupply: Long!
  tokenName: String
  issuer: String
  isBurnable: Boolean!
  issueChainId: Int!
}

scalar Long

input GetTokenInfoDto {
  symbol: String
  chainId: String
  skipCount: Int!
  maxResultCount: Int!
}

type NFTProtocolInfoDto {
  id: String
  chainId: String
  blockHash: String
  blockHeight: Long!
  previousBlockHash: String
  protocolName: String
  symbol: String
  tokenId: Long!
  owner: String
  minter: String
  quantity: Long!
  alias: String
  baseUri: String
  uri: String
  creator: String
  nftType: String
  totalQuantity: Long!
  tokenHash: String
  imageUrl: String
}

input GetNFTProtocolInfoDto {
  symbol: String
  chainId: String
  skipCount: Int!
  maxResultCount: Int!
}

type CAHolderTransactionDto {
  id: String
  chainId: String
  blockHash: String
  blockHeight: Long!
  previousBlockHash: String
  transactionId: String
  methodName: String
  tokenInfo: TokenInfo
  nftInfo: NFTInfo
  status: TransactionStatus!
  timestamp: Long!
  transferInfo: TransferInfo
  fromAddress: String
  transactionFees: [TransactionFee]
}

type TokenInfo {
  symbol: String
  decimals: Int!
}

type NFTInfo {
  url: String
  alias: String
  nftId: Long!
}

enum TransactionStatus {
  NOT_EXISTED
  PENDING
  FAILED
  MINED
  CONFLICT
  PENDING_VALIDATION
  NODE_VALIDATION_FAILED
}

type TransferInfo {
  fromAddress: String
  toAddress: String
  amount: Long!
  fromChainId: String
  toChainId: String
}

type TransactionFee {
  symbol: String
  amount: Long!
}

input GetCAHolderTransactionDto {
  chainId: String
  symbol: String
  caAddresses: [String]
  transactionId: String
  blockHash: String
  methodNames: [String]
  skipCount: Int!
  maxResultCount: Int!
}

type CAHolderManagerDto {
  id: String
  chainId: String
  caHash: String
  caAddress: String
  managers: [ManagerInfo]
}

type ManagerInfo {
  manager: String
  deviceString: String
}

input GetCAHolderManagerInfoDto {
  chainId: String
  caHash: String
  caAddresses: [String]
  manager: String
  skipCount: Int!
  maxResultCount: Int!
}

type LoginGuardianAccountDto {
  id: String
  chainId: String
  caHash: String
  caAddress: String
  manager: String
  loginGuardianAccount: GuardianAccountDto
}

type GuardianAccountDto {
  guardian: GuardianDto
  value: String
}

type GuardianDto {
  type: Int!
  verifier: String
}

input GetLoginGuardianAccountInfoDto {
  chainId: String
  caHash: String
  caAddress: String
  loginGuardianAccount: String
  skipCount: Int!
  maxResultCount: Int!
}

type UserNFTProtocolInfoDto {
  id: String
  chainId: String
  caAddress: String
  tokenIds: [Long!]
  nftProtocolInfo: NFTProtocolDto
}

type NFTProtocolDto {
  id: String
  symbol: String
  creator: String
  nftType: String
  protocolName: String
  baseUri: String
  isTokenIdReuse: Boolean!
  supply: Long!
  totalSupply: Long!
  issueChainId: Int!
  isBurnable: Boolean!
  imageUrl: String
}

input GetUserNFTProtocolInfoDto {
  chainId: String
  symbol: String
  caAddresses: [String]
  skipCount: Int!
  maxResultCount: Int!
}

type UserNFTInfoDto {
  id: String
  chainId: String
  caAddress: String
  balance: Long!
  nftInfo: NFTItemInfoDto
}

type NFTItemInfoDto {
  id: String
  protocolName: String
  symbol: String
  tokenId: Long!
  owner: String
  minter: String
  quantity: Long!
  alias: String
  baseUri: String
  uri: String
  creator: String
  nftType: String
  totalQuantity: Long!
  tokenHash: String
  imageUrl: String
}

input GetUserNFTInfoDto {
  chainId: String
  symbol: String
  tokenId: Long! = 0
  caAddresses: [String]
  skipCount: Int!
  maxResultCount: Int!
}

type CAHolderTokenBalanceDto {
  chainId: String
  caAddress: String
  tokenInfo: TokenInfo
  balance: Long!
}

input GetCAHolderTokenBalanceDto {
  chainId: String
  caAddresses: [String]
  symbol: String
  skipCount: Int!
  maxResultCount: Int!
}

type CAHolderTransactionAddressDto {
  chainId: String
  caAddress: String
  address: String
  addressChainId: String
  transactionTime: Long!
}

input GetCAHolderTransactionAddressDto {
  chainId: String
  caAddress: String
  skipCount: Int!
  maxResultCount: Int!
}

type LoginGuardianAccountChangeRecordDto {
  changeType: String
  blockHeight: Long!
  id: String
  chainId: String
  caHash: String
  caAddress: String
  manager: String
  loginGuardianAccount: GuardianAccountDto
}

input GetLoginGuardianAccountChangeRecordDto {
  chainId: String
  startBlockHeight: Long!
  endBlockHeight: Long!
}

type CAHolderManagerChangeRecordDto {
  caAddress: String
  caHash: String
  manager: String
  changeType: String
  blockHeight: Long!
}

input GetCAHolderManagerChangeRecordDto {
  chainId: String
  startBlockHeight: Long!
  endBlockHeight: Long!
}

type CAHolderSearchTokenNFTDto {
  chainId: String
  caAddress: String
  balance: Long!
  tokenInfo: TokenSearchInfoDto
  nftInfo: NFTSearchInfoDto
}

type TokenSearchInfoDto {
  symbol: String
  tokenContractAddress: String
  decimals: Int!
  totalSupply: Long!
  tokenName: String
  issuer: String
  isBurnable: Boolean!
  issueChainId: Int!
}

type NFTSearchInfoDto {
  protocolName: String
  symbol: String
  tokenId: Long!
  nftContractAddress: String
  owner: String
  minter: String
  quantity: Long!
  alias: String
  baseUri: String
  uri: String
}

input GetCAHolderSearchTokenNFTDto {
  chainId: String
  caAddress: String
  searchWord: String
  skipCount: Int!
  maxResultCount: Int!
}

type SyncStateDto {
  confirmedBlockHeight: Long!
}

input GetSyncStateDto {
  chainId: String
  filterType: BlockFilterType!
}

enum BlockFilterType {
  BLOCK
  TRANSACTION
  LOG_EVENT
}
